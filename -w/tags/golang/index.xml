<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on 后端小筑</title>
    <link>http://localhost:1313/tags/golang/</link>
    <description>Recent content in Golang on 后端小筑</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 27 Sep 2017 17:13:39 +0800</lastBuildDate>
    <atom:link href="/tags/golang/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Go代码块库</title>
      <link>http://localhost:1313/post/2017/08/go%E4%BB%A3%E7%A0%81%E5%9D%97%E5%BA%93/</link>
      <pubDate>Wed, 27 Sep 2017 17:13:39 +0800</pubDate>
      
      <guid>http://localhost:1313/post/2017/08/go%E4%BB%A3%E7%A0%81%E5%9D%97%E5%BA%93/</guid>
      <description> 工具 时间日期 获取上个月第一天和最后一天 import ( &amp;quot;fmt&amp;quot; &amp;quot;time&amp;quot; ) func main() { t := time.Date(time.Now().Year(), time.February, 0, 0, 0, 0, 0, time.Local) fmt.Println(t.Format(&amp;quot;2006-01-02&amp;quot;)) tLastMonth := t.AddDate(0, -1, 0) fmt.Println(tLastMonth.Format(&amp;quot;2006-01-02&amp;quot;)) tLastMonth_Start := time.Date(tLastMonth.Year(), tLastMonth.Month(), 1, 0, 0, 0, 0, time.Local) tLastMonth_End := time.Date(t.Year(), t.Month(), 1, 0, 0, 0, 0, time.Local).AddDate(0, 0, -1) fmt.Println(&amp;quot;起始:&amp;quot;, tLastMonth_Start.Format(&amp;quot;2006-01-02 00:00:00&amp;quot;), &amp;quot;终止时间:&amp;quot;, tLastMonth_End.Format(&amp;quot;2006-01-02 00:00:00&amp;quot;)) }  并发 第三方库使用 性能 数据库 </description>
    </item>
    
    <item>
      <title>Websocket使用手记</title>
      <link>http://localhost:1313/post/2017/07/websocket%E4%BD%BF%E7%94%A8%E6%89%8B%E8%AE%B0/</link>
      <pubDate>Thu, 21 Sep 2017 23:51:49 +0800</pubDate>
      
      <guid>http://localhost:1313/post/2017/07/websocket%E4%BD%BF%E7%94%A8%E6%89%8B%E8%AE%B0/</guid>
      <description> websocket是什么? Websocket最起初是在HTTP协议的基础上发展而来，后独立成为了一个标准。其特点是只要建立一次连接，即可保持服务端与客户端的长连接状态，期间可保持全双工的通讯(实时双方互传)。由于省去了重复建立连接产生的性能和带宽消耗，WebSocket可实现高性能的数据实时传递。
用于什么场景? 可应用在前后端数据需要实时数据互传的情况，比如：
 聊天系统 股票显示 实时对战游戏 你画我猜游戏  为什么要选用它? 在网页数据前后端交互上与WebSocket相近的解决方案是长连接，其原理通过HTTP协议建立一个tcp连接，期间交互通信仍然采用HTTP方式。而Websocket的区别就在于连接后的通信采用的是其独立的方式，对比起HTTP的请求头要精简许多，这意味着其交互的实时性优于长连接。 另一方面，目前websocket的兼容性还是需要提高。
所以在实际应用场景上，如果数据交互频率大，
使用过程 服务端 目前Go语言主流的Websocket库有两个：
+ 官方golang.org/x/websocket 库 + github.com/gorilla/websocket 库 官方的库目前支持情况不太理想,godoc官方的websocket包页面介绍上推荐使用Gorilla的库。两者对比下，官方的包目前能够实现基本的服务器和客户端连接、收发功能。如果需要快捷开发基本WebSocket功能可使用官方包。需要协议的高级功能的推荐采用Gorilla包。
Gorilla/websocket包，丰富了支持Websocket协议内的数据压缩、心跳检测事件、碎片信息。
程序结构
websocket &amp;mdash; main() &amp;ndash; 注册普通HTTP路由 &amp;ndash; 监听HTTP服务 &amp;mdash; websocket_handler() &amp;ndash; Upgrade 升级普通HTTP协议为Websocket协议，建立连接 &amp;ndash; For循环 &amp;ndash; ReadMessage 读取信息 &amp;ndash; WriteMessage 写入信息
服务端的编写并不复杂，与普通HTTP服务编写相近，先编写一个Handler处理函数，再在主程序中注册路由，开启服务，不同的主要在处理函数中。由于普通HTTP的响应都是无状态，即请求后响应即可退出协程，但Websocket需要协程一直在跑，而且句柄固定，因此我们需要在Websocket的处理函数中加入循环，不让它关闭。
 客户端主动断开连接 服务端接收信息失败 服务端发送信息失败 心跳检查失败  客户端 javascript golang </description>
    </item>
    
  </channel>
</rss>
