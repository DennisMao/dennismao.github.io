<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>后端小筑 on 后端小筑</title>
    <link>http://localhost:1313/</link>
    <description>Recent content in 后端小筑 on 后端小筑</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 19 Oct 2017 23:38:17 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>系统监控:InfluxDB vs Elasticsearch</title>
      <link>http://localhost:1313/post/2017/10/%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7influxdbvselasticsearch/</link>
      <pubDate>Thu, 19 Oct 2017 23:38:17 +0800</pubDate>
      
      <guid>http://localhost:1313/post/2017/10/%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7influxdbvselasticsearch/</guid>
      <description>前言 译者: Razil
本文译自: System monitoring with InfluxDB vs Elasticsearch
系统的监控一直都扮演着重要角色。它能帮助我们了解系统的健康情况,发现问题甚至能预测问题。
如今，由于以下这些原因监控变得越来越重要:
 云服务（存储价格的降低）使我们可以一直监控和存储几乎所有东西 系统变得越来越复杂。系统包含了各种各样的灵活部件比如虚拟机、docker、数据库和服务,应有尽有。 物联网的逐步普及使得大量的硬件设备需要我们去追踪和监测。 数据分析得以升级，让我们只需要通过关注系统的稳定性和健康状态，就能达到了解客户需求、掌握发展趋势、对客户进行分类等多种目的。  本文将对比两个流行的监控解决方案。两者有着不同的处理方法和实现方式，相比起来各有千秋。 首先是TICK框架中的InfluxDB，第二个是ELK框架中的Elasticsearch。
什么是监控？ 监控由以下活动组成：
 采集数据 保存数据 可视化数据 产生告警  TICK Tick框架:
 Telegraf - 用于在系统运行时从系统或者其他服务采集指标和数据 InfluxDB - 高可用和高性能的时序数据库 Chronograf - 数据可视化的web应用 Kapacitor - 告警和数据处理引擎  本框架的而核心是时序数据库InfluxDB。时序数据库(Time series database TSDB)是一个为了处理时序数据(一系列由时间作为索引的数据)而特别优化的软件系统。例如，一段时间内锅炉里的水温或者一段时间内CPU的使用率。TSDB是一个NoSQL数据库，它支持增删改查操作和条件查询。与其他类型数据库最大的区别在于，它能在数据量庞大的情况下对时间索引维护的最优化。其他主要的时序数据库有 Graphite,Prometheus,OpenTSDB等等。我选择InfluxDB的真实原因是它是一个现代的数据库，用Go语言编写，非常容易安装和配置，而且性能出色。
InfluxDB的数据模型 InfluxDB 是一种无模式数据库。我们可以任意添加series,measurements和tags。例如：
app_degrees, country=Canada, city=Toronto degree=77.5 1422568543702900257  相关术语（这里表述的还是比较抽象，括号是本人的理解）:
 Measurement - 一个数字值 (相当于关系型数据里的一个表) Series - 数据收集和分析的单位 (一个表里数据的系列,可以理解为多条曲线) Tag - Key/Value 键值对,可选,用于描述measurement (字符串型的键值对，用于描述这个点，可以用作索引) Timestamp - Measurement的确切时间点(微妙级时间戳)  这个模型是的我们可以高效而且便捷地插入Measurements。</description>
    </item>
    
    <item>
      <title>Go代码块库</title>
      <link>http://localhost:1313/post/2017/08/go%E4%BB%A3%E7%A0%81%E5%9D%97%E5%BA%93/</link>
      <pubDate>Wed, 27 Sep 2017 17:13:39 +0800</pubDate>
      
      <guid>http://localhost:1313/post/2017/08/go%E4%BB%A3%E7%A0%81%E5%9D%97%E5%BA%93/</guid>
      <description> 工具 时间日期 获取上个月第一天和最后一天 import ( &amp;quot;fmt&amp;quot; &amp;quot;time&amp;quot; ) func main() { t := time.Date(time.Now().Year(), time.February, 0, 0, 0, 0, 0, time.Local) fmt.Println(t.Format(&amp;quot;2006-01-02&amp;quot;)) tLastMonth := t.AddDate(0, -1, 0) fmt.Println(tLastMonth.Format(&amp;quot;2006-01-02&amp;quot;)) tLastMonth_Start := time.Date(tLastMonth.Year(), tLastMonth.Month(), 1, 0, 0, 0, 0, time.Local) tLastMonth_End := time.Date(t.Year(), t.Month(), 1, 0, 0, 0, 0, time.Local).AddDate(0, 0, -1) fmt.Println(&amp;quot;起始:&amp;quot;, tLastMonth_Start.Format(&amp;quot;2006-01-02 00:00:00&amp;quot;), &amp;quot;终止时间:&amp;quot;, tLastMonth_End.Format(&amp;quot;2006-01-02 00:00:00&amp;quot;)) }  并发 第三方库使用 性能 数据库 </description>
    </item>
    
    <item>
      <title>Go爬虫初探</title>
      <link>http://localhost:1313/post/2017/10/go%E7%88%AC%E8%99%AB%E5%88%9D%E6%8E%A2/</link>
      <pubDate>Tue, 26 Sep 2017 23:29:00 +0800</pubDate>
      
      <guid>http://localhost:1313/post/2017/10/go%E7%88%AC%E8%99%AB%E5%88%9D%E6%8E%A2/</guid>
      <description>背景 前些天用Python实践了一下爬虫功能，强大的requests库、re库、beautifulsoup库和scrapy框架以及其附属的分布式数据库配套库，开发起来十分高效。对于复杂的爬虫规则和验证规则，Python的相关生态也能提供很好的解决方案。回到golang，也想尝试是否能用go语言也构建一个基本爬虫，看实现上会有多大差异。
目标功能 获取 http://razil.cc 首页上的网站名称元素内容。
目标内容为“后端小筑”
基本结构 由于是基本的定向爬虫，类比Python的结构是
requests库 + re库
即基本请求后处理转码，再通过正则获得需要的数据
在go实现的结构如下:
 [net/http] 基本请求
 [mahonia] 第三方库实现编码转换
 [regexp] 正则匹配数据
  代码实现 package main import ( &amp;quot;errors&amp;quot; &amp;quot;fmt&amp;quot; &amp;quot;io/ioutil&amp;quot; &amp;quot;net/http&amp;quot; &amp;quot;regexp&amp;quot; encodingConvert &amp;quot;github.com/DennisMao/mahonia&amp;quot; ) func SimpleScrapy(url string) (string, error) { //http请求 resp, err := http.Get(url) if err != nil { return &amp;quot;&amp;quot;, err } //获取响应数据 if resp.StatusCode != 200 { return &amp;quot;&amp;quot;, errors.New(&amp;quot;resp statuscode = :&amp;quot; + fmt.</description>
    </item>
    
    <item>
      <title>《CSAPP》读书笔记</title>
      <link>http://localhost:1313/post/2017/10/csapp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Thu, 21 Sep 2017 23:58:01 +0800</pubDate>
      
      <guid>http://localhost:1313/post/2017/10/csapp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
      <description> 章1 计算机系统漫游  并发和并行 【并发】同一时间具有多个活动 【并行】用并发来使一个系统运行更快  线程级并发 通过使计算机在进程间快速切换，以模拟达到并发的效果 指令级并行 定义：现代处理器可以同时执行多条指令的属性，通过这个模型可以优化程序设计，使其运行指令符合处理器的并行优化要求。核心【流水线Pipeline】 单指令、多数据并行 定义：现代处理器允许一条指令产生多个可以并行执行的操作  计算机系统的抽象  虚拟机  操作系统 进程  指令架构  处理器  虚拟内存  主存 文件（I/O设备）       章2 章3 章4 章5 章6 章7 章9 虚拟内存 +【虚拟内存】: 主存的抽象，为硬件异常、硬件地址翻译、主存、磁盘文件和内核软件提供交互，为每个进程提供一个大的、一致的、和私有的地址空间
三个重要能力:
+ 将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传输数据 + 为每个进程提供一致的地址空间，简化内存管理 + 保护了每个进程的地址空间不被其他进程破坏
章10 章11 章12 </description>
    </item>
    
    <item>
      <title>Websocket使用手记</title>
      <link>http://localhost:1313/post/2017/07/websocket%E4%BD%BF%E7%94%A8%E6%89%8B%E8%AE%B0/</link>
      <pubDate>Thu, 21 Sep 2017 23:51:49 +0800</pubDate>
      
      <guid>http://localhost:1313/post/2017/07/websocket%E4%BD%BF%E7%94%A8%E6%89%8B%E8%AE%B0/</guid>
      <description> websocket是什么? Websocket最起初是在HTTP协议的基础上发展而来，后独立成为了一个标准。其特点是只要建立一次连接，即可保持服务端与客户端的长连接状态，期间可保持全双工的通讯(实时双方互传)。由于省去了重复建立连接产生的性能和带宽消耗，WebSocket可实现高性能的数据实时传递。
用于什么场景? 可应用在前后端数据需要实时数据互传的情况，比如：
 聊天系统 股票显示 实时对战游戏 你画我猜游戏  为什么要选用它? 在网页数据前后端交互上与WebSocket相近的解决方案是长连接，其原理通过HTTP协议建立一个tcp连接，期间交互通信仍然采用HTTP方式。而Websocket的区别就在于连接后的通信采用的是其独立的方式，对比起HTTP的请求头要精简许多，这意味着其交互的实时性优于长连接。 另一方面，目前websocket的兼容性还是需要提高。
所以在实际应用场景上，如果数据交互频率大，
使用过程 服务端 目前Go语言主流的Websocket库有两个：
+ 官方golang.org/x/websocket 库 + github.com/gorilla/websocket 库 官方的库目前支持情况不太理想,godoc官方的websocket包页面介绍上推荐使用Gorilla的库。两者对比下，官方的包目前能够实现基本的服务器和客户端连接、收发功能。如果需要快捷开发基本WebSocket功能可使用官方包。需要协议的高级功能的推荐采用Gorilla包。
Gorilla/websocket包，丰富了支持Websocket协议内的数据压缩、心跳检测事件、碎片信息。
程序结构
websocket &amp;mdash; main() &amp;ndash; 注册普通HTTP路由 &amp;ndash; 监听HTTP服务 &amp;mdash; websocket_handler() &amp;ndash; Upgrade 升级普通HTTP协议为Websocket协议，建立连接 &amp;ndash; For循环 &amp;ndash; ReadMessage 读取信息 &amp;ndash; WriteMessage 写入信息
服务端的编写并不复杂，与普通HTTP服务编写相近，先编写一个Handler处理函数，再在主程序中注册路由，开启服务，不同的主要在处理函数中。由于普通HTTP的响应都是无状态，即请求后响应即可退出协程，但Websocket需要协程一直在跑，而且句柄固定，因此我们需要在Websocket的处理函数中加入循环，不让它关闭。
 客户端主动断开连接 服务端接收信息失败 服务端发送信息失败 心跳检查失败  客户端 javascript golang </description>
    </item>
    
    <item>
      <title>Proto3使用手记</title>
      <link>http://localhost:1313/post/2017/08/proto3%E4%BD%BF%E7%94%A8%E6%89%8B%E8%AE%B0/</link>
      <pubDate>Tue, 22 Aug 2017 23:49:14 +0800</pubDate>
      
      <guid>http://localhost:1313/post/2017/08/proto3%E4%BD%BF%E7%94%A8%E6%89%8B%E8%AE%B0/</guid>
      <description>Proto3 是什么？ 最近正在使用gRPC，当前版本gRPC使用的是google开发的Proto 3版本，因此顺带写一篇。Proto 3全称是 Protocol buffers v3.0,是谷歌公司开发的一款序列化数据结构。支持多种语言。与proto2相比主要有以下几点改变：
 原生支持更多语言 JavaNano,Go,Ruby,Objective-C和C#等 调整部分语法 比如 default,optional,repeated 使得语法更简洁
 增加部分特性   具体改变介绍推荐以下这篇文章
Protobuf 的 proto3 与 proto2 的区别
最新特性详情可查阅
Protobuf Release
Proto3 有何功能? 通过定义接口描述文件 .proto文件，可通过这些描述自动生成出响应代码，用于编列或解码数据流。
为什么要选用它？ 使用过程中需要注意什么？ 使用过程 参考资料 Proto3 开发文档</description>
    </item>
    
    <item>
      <title>关于我</title>
      <link>http://localhost:1313/about/</link>
      <pubDate>Sun, 20 Aug 2017 09:49:04 +0800</pubDate>
      
      <guid>http://localhost:1313/about/</guid>
      <description>职位 后端开发工程师
工作经历 项目经历 技术栈 Golang、Java语言的Web后端，C++音视频。
联系方式 邮箱: psrazil@gmail.com Github: dennismao.github.com Blog: dennismao.github.io</description>
    </item>
    
  </channel>
</rss>
