<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on 行者小筑</title>
    <link>dennismao.github.io/categories/go/</link>
    <description>Recent content in Go on 行者小筑</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 28 Jan 2018 22:53:37 +0800</lastBuildDate>
    <atom:link href="dennismao.github.io/categories/go/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>2017 Go语言使用总结</title>
      <link>dennismao.github.io/post/2018/01/go-practices-in-2017/</link>
      <pubDate>Sun, 28 Jan 2018 22:53:37 +0800</pubDate>
      
      <guid>dennismao.github.io/post/2018/01/go-practices-in-2017/</guid>
      <description>到了年末，谈谈这一年的收获与坑。
所参与的项目从C++转到Go有两年，产品今年已经正式投入到线上商用运行。自己也从刚开始的基础模块设计开发，逐渐转到上层业务的开发。从底层到业务层的转变，对语言的需求和看法，也了有一定的变化。作为小coder，谈谈这年在实际项目中用Go语言的一些心得和踩坑经历。
语法风格简单 Go在开发方面很吸引人的一点就是语法简单，容易上手。组里的同事基本都是从C++和JAVA两个方向转到Go语言来开发这个项目。通过相互沟通，大家普通花了一个月时间左右熟悉这门语言并能上手进行开发实际模块。因为有官方的gofmt格式化工具，大家的代码风格都基本与《effective go》中的相近。这点好处就是非常有效地提高code review的效率和效果。
关于网上的一直争议的错误处理，团队也有过讨论。讨论的结果就是两种方案有原则的并存,根据业务情况进行选择。 在一般流程中，使用独立的错误处理
if err := func();err != nil { return err }  在业务流中，使用统一的错误处理
func xx() (err error) { defer func() { if err != nil { collcetErr(err) return } }() return }  支持跨平台 在go 1.5后，语言原生支持了跨平台编译，通过设置环境参数GOOS和GOARCH,直接go build，即可非常便捷地进行跨平台编译。如果代码中有需要加入CGO的东西，则会稍麻烦些。与所在操作系统一下，安装支持跨平台编辑gcc，在go env中配置好cc的参数即可。由于项目需要兼容多种环境，支持跨平台编辑还是非常便于开发和部署管理。
高性能、低消耗、易部署 实际项目使用中最明显的应该是它的运行效率非常高、内存消耗低和直接可以生成可执行文件部署起来十分便捷。生成出的可执行文件体积很小，生成docker container体积相比起java的也是小不少。 当然效率高和消耗低与开发是密切相关的。前期在对语言使用上还不够理解深入的情况下，开发过程中会有出现部分内存泄漏、GC过频等情况。通过官方提供的pprof、test包和benchmark工具，搭配像flamegraph等工具。可以高效地进行程序的漏洞修复和性能调优。
有了上述的优点，团队也开始考虑能否能进一步拓宽Go语言的应用领域，往物联网和其他硬件相关的领域发展。
坑 说完了优点，再说说开发和应用过程中，踩过的坑和一些解决方法。
滥用协程 由于在绝大部分介绍中都强调了Go的goroutine优势，在前面的优点讲述中就不再过多描述。但是正因为Go开协程是如此便捷，在初期开发时，会遇到在底层模块中滥用goroutine的现象。部分协程由于开了后，跑完主任务却没有正确关闭，资源一直被占用。 对于这种解决方法有三个。 (1)针对编程习惯上，参考了官方的并发模型，对代码质量进行规范，加强code review中这部分的检查。通过runtime/pprof包能十分便捷有效地查看当前的goroutine信息，判断是否有异常和未正确关闭的协程。 (2)引入context包进行上下文控制，在并发模型中有cancel和wait模型，底层模块我们更多选择的是cancel模型来规范和解决goroutine管理的问题。但是在业务流程调用的时候会偏向于选择wait模型。 (3)构建集中的任务管理器包，采用注册的方式对需要用到goroutine的任务采用wait模型进行管理。
第三方包质量 虽然官方的底层操作库已经十分完善，但在系统整个开发过程中难免会用到第三方包。而第三方包的质量问题一直存开发过程中。由于Go语言还属于一门新的语言，跟JAVA和C++相比，相关的第三方功能包都不是那么完善，在蓬勃发展中。所以在当前需要使用第三方包还是要格外慎重，决定引入之前需要根据项目需求进行深入测试。 这个问题主要影响是的开发的进度。底层组件开发过程，修复第三方包花费了一定时间。
下面整理了第三方包容易存在的一些问题: + 多系统环境兼容性: 第三方包容易出现只支持某个系统，多系统的兼容在设计初并未考虑到 + 版本控制: 早期包很多未采用版本控制，当第三方包内由引入其他包时候直接go get -u会引发各种奇怪问题。所以在进行二次开发时候注意增加像dep,glide这种，包的版本控制工具。 + CGO: 有部分包因为调用了c++/c的代码引入了cgo，在开发过程中着重检查其中的c/c++代码正确性。 + Go语言版本: 部分包会使用到一些新语法特性,像1.</description>
    </item>
    
    <item>
      <title>使用TravisCI持续部署Hugo博客到gitpages</title>
      <link>dennismao.github.io/post/2018/01/build-blog-by-hugo-and-travisci-on-gitpages/</link>
      <pubDate>Tue, 16 Jan 2018 23:04:21 +0800</pubDate>
      
      <guid>dennismao.github.io/post/2018/01/build-blog-by-hugo-and-travisci-on-gitpages/</guid>
      <description>背景 操作步骤 最终效果 注意事项 参考 Continuous Deployment: Hugo + Travis CI → GitHub Pages Hugo借助Travis CI实现GitHub Pages自动部署实践</description>
    </item>
    
    <item>
      <title>【Go】反射在Beego/Orm中的应用</title>
      <link>dennismao.github.io/post/2017/07/reflect-on-beego-orm/</link>
      <pubDate>Thu, 20 Jul 2017 15:03:41 +0800</pubDate>
      
      <guid>dennismao.github.io/post/2017/07/reflect-on-beego-orm/</guid>
      <description>应用 在Beego Orm中，作者使用了go的反射机制，实现 1、通过数据模型建立数据表
 type DataSheet struct { Name string orm:&amp;quot;NOT NULL&amp;quot; json:&amp;quot;name&amp;quot; //表名称 Type string orm:&amp;quot;NOT NULL&amp;quot; json:&amp;quot;type&amp;quot; //周期类型 日/月/季/年 Way string orm:&amp;quot;NOT NULL&amp;quot; json:&amp;quot;way&amp;quot; //生成方式 Time string orm:&amp;quot;NOT NULL&amp;quot; json:&amp;quot;time&amp;quot; //创建时间 Creator string orm:&amp;quot;NOT NULL&amp;quot; json:&amp;quot;creator&amp;quot; //制作人 }
 在调用 orm.RegisterModel(new(DataSheet)) 后会自动生成名为 data_sheet 的数据表 2、通过模型中的tag &amp;gt; orm:&amp;quot;auto;pk&amp;quot; &amp;gt; orm:&amp;quot;rel(m2m)&amp;quot;
自动设置字段属性和表之间关系
完整代码 package main import ( &amp;quot;errors&amp;quot; &amp;quot;fmt&amp;quot; &amp;quot;reflect&amp;quot; ) type DataSheet struct { Name string `orm:&amp;quot;NOT NULL&amp;quot; json:&amp;quot;name&amp;quot;` //表名称 Type string `orm:&amp;quot;NOT NULL&amp;quot; json:&amp;quot;type&amp;quot;` //周期类型 日/月/季/年 Way string `orm:&amp;quot;NOT NULL&amp;quot; json:&amp;quot;way&amp;quot;` //生成方式 Time string `orm:&amp;quot;NOT NULL&amp;quot; json:&amp;quot;time&amp;quot;` //创建时间 Creator string `orm:&amp;quot;NOT NULL&amp;quot; json:&amp;quot;creator&amp;quot;` //制作人 } func main() { fmt.</description>
    </item>
    
    <item>
      <title>【Go】解决“can&#39;t load package: no buildable Go source files in /...</title>
      <link>dennismao.github.io/post/2017/05/solve-no-buildable-go-source/</link>
      <pubDate>Sat, 20 May 2017 15:10:00 +0800</pubDate>
      
      <guid>dennismao.github.io/post/2017/05/solve-no-buildable-go-source/</guid>
      <description>最近在调用golang.org/x/net出现这个错误。经检查后解决方法如下。在调用外部包时候出现这种情况，应检查以下设置 &amp;gt; 1.目标外部包的编译环境是否与当前工程的环境相同 2.先使用go get 获取外部包 使用 go install 直接编译安装
关于本地未科学上网的情况下使用golang.org官方包的方法 &amp;gt; 1.到https://github.com/golang/找到对应的包的镜像文件 2.下载zip文件，解压后，修改文件目录为原始 golang.org目录 3.go install 编译安装
举个实例: golang.org/x/net 对应 github上的镜像地址是 https://github.com/golang/net</description>
    </item>
    
    <item>
      <title>【Go】常用的正则表达式</title>
      <link>dennismao.github.io/post/2017/05/go-regexp-pkg/</link>
      <pubDate>Wed, 17 May 2017 14:58:17 +0800</pubDate>
      
      <guid>dennismao.github.io/post/2017/05/go-regexp-pkg/</guid>
      <description>/*********************************************************** *名字 golang 正则工具 *功能 支持数字，字母，字符，常用信息（电话，邮箱）等的正则匹配 *作者 Razil ************************************************************/ package models import ( &amp;quot;regexp&amp;quot; ) type RegexCheck struct { } /************************* 自定义类型 ************************/ //数字+字母 不限制大小写 6~30位 func (ic *RegexCheck) IsID(str ...string) bool { var b bool for _, s := range str { b, _ = regexp.MatchString(&amp;quot;^[0-9a-zA-Z]{6,30}$&amp;quot;, s) if false == b { return b } } return b } //数字+字母+符号 6~30位 func (ic *RegexCheck) IsPwd(str ...string) bool { var b bool for _, s := range str { b, _ = regexp.</description>
    </item>
    
    <item>
      <title>【docker】Docker实战 - 将go工程部署到docker</title>
      <link>dennismao.github.io/post/2017/04/docker-deploy-1/</link>
      <pubDate>Wed, 19 Apr 2017 15:24:29 +0800</pubDate>
      
      <guid>dennismao.github.io/post/2017/04/docker-deploy-1/</guid>
      <description>###目标功能 + 使用go语言实现基本http服务 访问 localhost:8080 时能够返回 &amp;ldquo;hellodocker&amp;rdquo; + 将工程部署到docker，并在后台启动 ###环境介绍 docker: golang: host(宿主机环境): Mac os 10.12
###重点难点 + dockerfile结构 + docker网络结构
###操作步骤
Go工程 1 在本机新建go工程，目录名为hellodocker
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;net/http&amp;quot; ) func indexHandler(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, &amp;quot;hello docker&amp;quot;) } func main() { http.HandleFunc(&amp;quot;/&amp;quot;, indexHandler) http.ListenAndServe(&amp;quot;:8080&amp;quot;, nil) }  2 编译和执行 3 打开浏览器输入 localhost:8080 当屏幕出现 &amp;ldquo;hellodocker&amp;rdquo;说明程序正常
制作docker镜像 1 在工程目录hellodocker下，新建dockerfile文件
FROM golang:latest MAINTAINER Razil &amp;quot;raymond_2008@yahoo.com&amp;quot; WORKDIR $GOPATH/src/hellodocker ADD .</description>
    </item>
    
    <item>
      <title>【Go】Web加密方案与Go语言解决</title>
      <link>dennismao.github.io/post/2017/03/go-encrypt/</link>
      <pubDate>Tue, 28 Mar 2017 00:08:18 +0800</pubDate>
      
      <guid>dennismao.github.io/post/2017/03/go-encrypt/</guid>
      <description>常见加密方案 ###1、对称加密： 即加密方和解密方都使用相同的加密算法和密钥，这种方案的密钥的保存非常关键，因为算法是公开的，而密钥是保密的，一旦密匙泄露，黑客仍然可以轻易解密。 常见的对称加密算法有：AES、DES、3DES、Blowfish、IDEA、RC4、RC5、RC6和 等。
###2、非对称加密： 即使用不同的密钥来进行加解密，密钥被分为公钥和私钥，用私钥加密的数据必须使用公钥来解密，同样用公钥加密的数据必须用对应的私钥来解密， 常见的非对称加密算法有：RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用）等。
###3、不可逆加密： 利用哈希算法使数据加密之后无法解密回原数据。 这样的哈希算法常用的有：SHA-256, SHA-1, MD2、MD4、MD5、HAVAL等。
Go语言对这三种加密算法的实现如下所示：
//import &amp;quot;crypto/sha256&amp;quot; h := sha256.New() io.WriteString(h, &amp;quot;His money is twice tainted: &#39;taint yours and &#39;taint mine.&amp;quot;) fmt.Printf(&amp;quot;% x&amp;quot;, h.Sum(nil)) //import &amp;quot;crypto/sha1&amp;quot; h := sha1.New() io.WriteString(h, &amp;quot;His money is twice tainted: &#39;taint yours and &#39;taint mine.&amp;quot;) fmt.Printf(&amp;quot;% x&amp;quot;, h.Sum(nil)) //import &amp;quot;crypto/md5&amp;quot; h := md5.New() io.WriteString(h, &amp;quot;需要加密的密码&amp;quot;) fmt.Printf(&amp;quot;%x&amp;quot;, h.Sum(nil))  加密解决方案 1. MD5加盐  对MD5加密的数据加入揉合进特定的随机数，再二次生成MD5。
 在我们上面登录系统的示例代码中，$md5password = md5($password); 从这句代码可以看到采用了md5的不可逆加密算法来存储密码，这也是多年来业界常用的密码加密算法，但是这仍然不安全。为什么呢？这是因为md5加密有一个特点：同样的字符串经过md5哈希计算之后生成的加密字符串也是相同的，由于业界采用这种加密的方式由来已久，黑客们也准备了自己强大的md5彩虹表来逆向匹配加密前的字符串，这种用于逆向反推MD5加密的彩虹表在互联网上随处可见，在Google里使用md5 解密作为关键词搜索，一下就能找到md5在线破解网站，把我们插入用户数据时候的MD5加密字符串e10adc3949ba59abbe56e057f20f883e填入进去，瞬间就能得到加密前的密码：123456。</description>
    </item>
    
  </channel>
</rss>
