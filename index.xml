<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>行者小筑 on 行者小筑</title>
    <link>/</link>
    <description>Recent content in 行者小筑 on 行者小筑</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>@2017-2018 版权所有.</copyright>
    <lastBuildDate>Sun, 28 Jan 2018 22:53:37 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>2017 Go语言使用总结</title>
      <link>/post/2018/01/go-practices-in-2017/</link>
      <pubDate>Sun, 28 Jan 2018 22:53:37 +0800</pubDate>
      
      <guid>/post/2018/01/go-practices-in-2017/</guid>
      <description>到了年末，谈谈这一年的收获与坑。
所参与的项目从C++转到Go有两年，产品今年已经正式投入到线上商用运行。自己也从刚开始的基础模块设计开发，逐渐转到上层业务的开发。从底层到业务层的转变，对语言的需求和看法，也了有一定的变化。作为小coder，谈谈这年在实际项目中用Go语言的一些心得和踩坑经历。
语法风格简单 Go在开发方面很吸引人的一点就是语法简单，容易上手。组里的同事基本都是从C++和JAVA两个方向转到Go语言来开发这个项目。通过相互沟通，大家普通花了一个月时间左右熟悉这门语言并能上手进行开发实际模块。因为有官方的gofmt格式化工具，大家的代码风格都基本与《effective go》中的相近。这点好处就是非常有效地提高code review的效率和效果。
关于网上的一直争议的错误处理，团队也有过讨论。讨论的结果就是两种方案有原则的并存,根据业务情况进行选择。 在一般流程中，使用独立的错误处理
if err := func();err != nil { return err }  在业务流中，使用统一的错误处理
func xx() (err error) { defer func() { if err != nil { collcetErr(err) return } }() return }  支持跨平台 在go 1.5后，语言原生支持了跨平台编译，通过设置环境参数GOOS和GOARCH,直接go build，即可非常便捷地进行跨平台编译。如果代码中有需要加入CGO的东西，则会稍麻烦些。与所在操作系统一下，安装支持跨平台编辑gcc，在go env中配置好cc的参数即可。由于项目需要兼容多种环境，支持跨平台编辑还是非常便于开发和部署管理。
高性能、低消耗、易部署 实际项目使用中最明显的应该是它的运行效率非常高、内存消耗低和直接可以生成可执行文件部署起来十分便捷。生成出的可执行文件体积很小，生成docker container体积相比起java的也是小不少。 当然效率高和消耗低与开发是密切相关的。前期在对语言使用上还不够理解深入的情况下，开发过程中会有出现部分内存泄漏、GC过频等情况。通过官方提供的pprof、test包和benchmark工具，搭配像flamegraph等工具。可以高效地进行程序的漏洞修复和性能调优。
有了上述的优点，团队也开始考虑能否能进一步拓宽Go语言的应用领域，往物联网和其他硬件相关的领域发展。
坑 说完了优点，再说说开发和应用过程中，踩过的坑和一些解决方法。
滥用协程 由于在绝大部分介绍中都强调了Go的goroutine优势，在前面的优点讲述中就不再过多描述。但是正因为Go开协程是如此便捷，在初期开发时，会遇到在底层模块中滥用goroutine的现象。部分协程由于开了后，跑完主任务却没有正确关闭，资源一直被占用。 对于这种解决方法有三个。 (1)针对编程习惯上，参考了官方的并发模型，对代码质量进行规范，加强code review中这部分的检查。通过runtime/pprof包能十分便捷有效地查看当前的goroutine信息，判断是否有异常和未正确关闭的协程。 (2)引入context包进行上下文控制，在并发模型中有cancel和wait模型，底层模块我们更多选择的是cancel模型来规范和解决goroutine管理的问题。但是在业务流程调用的时候会偏向于选择wait模型。 (3)构建集中的任务管理器包，采用注册的方式对需要用到goroutine的任务采用wait模型进行管理。
第三方包质量 虽然官方的底层操作库已经十分完善，但在系统整个开发过程中难免会用到第三方包。而第三方包的质量问题一直存开发过程中。由于Go语言还属于一门新的语言，跟JAVA和C++相比，相关的第三方功能包都不是那么完善，在蓬勃发展中。所以在当前需要使用第三方包还是要格外慎重，决定引入之前需要根据项目需求进行深入测试。 这个问题主要影响是的开发的进度。底层组件开发过程，修复第三方包花费了一定时间。
下面整理了第三方包容易存在的一些问题: + 多系统环境兼容性: 第三方包容易出现只支持某个系统，多系统的兼容在设计初并未考虑到 + 版本控制: 早期包很多未采用版本控制，当第三方包内由引入其他包时候直接go get -u会引发各种奇怪问题。所以在进行二次开发时候注意增加像dep,glide这种，包的版本控制工具。 + CGO: 有部分包因为调用了c++/c的代码引入了cgo，在开发过程中着重检查其中的c/c++代码正确性。 + Go语言版本: 部分包会使用到一些新语法特性,像1.</description>
    </item>
    
    <item>
      <title>使用TravisCI持续部署Hugo博客到gitpages</title>
      <link>/post/2018/01/build-blog-by-hugo-and-travisci-on-gitpages/</link>
      <pubDate>Tue, 16 Jan 2018 23:04:21 +0800</pubDate>
      
      <guid>/post/2018/01/build-blog-by-hugo-and-travisci-on-gitpages/</guid>
      <description>背景 操作步骤 最终效果 注意事项 参考 Continuous Deployment: Hugo + Travis CI → GitHub Pages Hugo借助Travis CI实现GitHub Pages自动部署实践</description>
    </item>
    
    <item>
      <title>使用Beego处理多文件上传</title>
      <link>/post/2017/12/beego-multi-file-upload/</link>
      <pubDate>Wed, 27 Dec 2017 15:35:04 +0800</pubDate>
      
      <guid>/post/2017/12/beego-multi-file-upload/</guid>
      <description>实现方法 Beego 在controller处理上提供了GetFile和GetFiles方法，以获取MultipartForm里的文件内容。详细说明查看godoc。
获取单个文件 func (*Controller) GetFile
 func (c *Controller) GetFile(key string) (multipart.File, *multipart.FileHeader, error) GetFile returns the file data in file upload field named as key. it returns the first one of multi-uploaded files.
 获取多个文件 func (*Controller) GetFiles
 func (c *Controller) GetFiles(key string) ([]*multipart.FileHeader, error)
 本文结合示例代码和工程应用提供实际可用解决方法。 前端页面上传的请求格式按照rfc1867标准即可。 Body内容如下图所示
服务端代码 import( &amp;quot;io&amp;quot; &amp;quot;os&amp;quot; &amp;quot;strings&amp;quot; &amp;quot;github.com/astaxie/beego&amp;quot; &amp;quot;github.com/astaxie/beego/logs&amp;quot; ) //默认参数 const ( STATIC_PATH = &amp;quot;tmp/&amp;quot; ) //	文件信息格式 type FileRecord struct { FileName string `json:&amp;quot;file_name&amp;quot;` Path string `json:&amp;quot;path&amp;quot;` FileSize string `json:&amp;quot;file_size&amp;quot;` UploadTime string `json:&amp;quot;upload_time&amp;quot;` } //	上传 type UploadController struct { beego.</description>
    </item>
    
    <item>
      <title>使用Go语言处理动态JSON类型</title>
      <link>/post/2017/12/dynamic-json/</link>
      <pubDate>Thu, 14 Dec 2017 00:22:45 +0800</pubDate>
      
      <guid>/post/2017/12/dynamic-json/</guid>
      <description>背景 在项目中有遇到JSON格式的数据流，对接的数据源其内容格式会有变化，但是内部会有字段表示其内容的类型，比如以下结构:
type DataJson struct { JsonType string `json:&amp;quot;json_type&amp;quot;` Data interface{} `json:&amp;quot;data&amp;quot;` }  其中DataJson是固定每次数据流返回的JSON数据格式，但是其中的Data有以下几种可能：字符串、Int64数值、结构体对象。
这种情况需要根据Json去进行判断。
生成动态类型 在Go语言中通过使用interface{}类型，我们可以很方便地把各种数据类型都使用同一个数据对象中进行数据传递。 动态类型生成方式很简单:
type DataJson struct { JsonType string `json:&amp;quot;json_type&amp;quot;` Data interface{} `json:&amp;quot;data&amp;quot;` } func main(){ //定义两个JSON数据对象 var jsData1,jsData2 DataJson //String数据类型对象 jsData1.JsonType = &amp;quot;string&amp;quot; jsData1.Data = &amp;quot;hello json&amp;quot; //Int64数据类型对象 jsData2.JsonType = &amp;quot;int64&amp;quot; jsData2.Data = 123456789	}  解析动态类型 方法一 整体二次反序列化 核心原理是通过新建一个对象，将能已知的数据对象先解析并获取到目标数据类型后再进行二次解析。
//目标类型 type DataJson struct { JsonType string `json:&amp;quot;json_type&amp;quot;` Data interface{} `json:&amp;quot;data&amp;quot;`	} //中间类型 type DataJsonType struct { JsonType string `json:&amp;quot;json_type&amp;quot;` } //字符串类型 type DataJsonTypeString struct { Data string `json:&amp;quot;data&amp;quot;` } func main(){ //原始JSON数据 var rawData = ` { &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;, &amp;quot;data&amp;quot;: &amp;quot;dynamite&amp;quot; } ` buffer := []byte(rawData) //创建中间类型对象 var md DataJsonType err := json.</description>
    </item>
    
    <item>
      <title>2017文章汇总</title>
      <link>/post/2017/12/awsome-articles-2017/</link>
      <pubDate>Thu, 30 Nov 2017 20:54:52 +0800</pubDate>
      
      <guid>/post/2017/12/awsome-articles-2017/</guid>
      <description>基础 数据库 关系型 非关系型 深入理解etcd Etcd v3 服务注册与发现 Go代码
架构 高并发 分布式 设计模式 DDD TDD,BDD,FDD&amp;amp;ATDD
业务 AWS开发工具包发布适用Go 2.0的开发者预览版 JS实现的Markdown解析器
运维 软件 CentOS7 安装svn
CI Jenkins 基于jenkins整合ant和svn的持续集成环境 Jenkins+Maven+SVN快速搭建持续集成环境
Travis CI .travis.yml在线验证工具 Hexo持续集成自动部署到github travis.yml文件说明文档
测试 有趣项目 Go go-algorithms: 使用Go语言实现多种经典算法 TensorFlow用Go实现的图像识别</description>
    </item>
    
    <item>
      <title>[译]Context并非为cancel而生</title>
      <link>/post/2017/11/go-context-is-not-for-cancel/</link>
      <pubDate>Thu, 30 Nov 2017 20:47:48 +0800</pubDate>
      
      <guid>/post/2017/11/go-context-is-not-for-cancel/</guid>
      <description>前言 译者:Razil
本文译自:Context isn’t for cancellation</description>
    </item>
    
    <item>
      <title>系统监控:InfluxDB vs Elasticsearch</title>
      <link>/post/2017/10/influxdbvselasticsearch/</link>
      <pubDate>Thu, 19 Oct 2017 23:38:17 +0800</pubDate>
      
      <guid>/post/2017/10/influxdbvselasticsearch/</guid>
      <description>前言 译者: Razil
本文译自: System monitoring with InfluxDB vs Elasticsearch
系统的监控一直都扮演着重要角色。它能帮助我们了解系统的健康情况,发现问题甚至能预测问题。
如今，由于以下这些原因监控变得越来越重要:
 云服务（存储价格的降低）使我们可以一直监控和存储几乎所有东西 系统变得越来越复杂。系统包含了各种各样的灵活部件比如虚拟机、docker、数据库和服务,应有尽有。 物联网的逐步普及使得大量的硬件设备需要我们去追踪和监测。 数据分析得以升级，让我们只需要通过关注系统的稳定性和健康状态，就能达到了解客户需求、掌握发展趋势、对客户进行分类等多种目的。  本文将对比两个流行的监控解决方案。两者有着不同的处理方法和实现方式，相比起来各有千秋。 首先是TICK框架中的InfluxDB，第二个是ELK框架中的Elasticsearch。
什么是监控？ 监控由以下活动组成：
 采集数据 保存数据 可视化数据 产生告警  TICK Tick框架:
 Telegraf - 用于在系统运行时从系统或者其他服务采集指标和数据 InfluxDB - 高可用和高性能的时序数据库 Chronograf - 数据可视化的web应用 Kapacitor - 告警和数据处理引擎  本框架的而核心是时序数据库InfluxDB。时序数据库(Time series database TSDB)是一个为了处理时序数据(一系列由时间作为索引的数据)而特别优化的软件系统。例如，一段时间内锅炉里的水温或者一段时间内CPU的使用率。TSDB是一个NoSQL数据库，它支持增删改查操作和条件查询。与其他类型数据库最大的区别在于，它能在数据量庞大的情况下对时间索引维护的最优化。其他主要的时序数据库有 Graphite,Prometheus,OpenTSDB等等。我选择InfluxDB的真实原因是它是一个现代的数据库，用Go语言编写，非常容易安装和配置，而且性能出色。
InfluxDB的数据模型 InfluxDB 是一种无模式数据库。我们可以任意添加series,measurements和tags。例如：
app_degrees, country=Canada, city=Toronto degree=77.5 1422568543702900257  相关术语（这里表述的还是比较抽象，括号是本人的理解）:
 Measurement - 一个数字值 (相当于关系型数据里的一个表) Series - 数据收集和分析的单位 (一个表里数据的系列,可以理解为多条曲线) Tag - Key/Value 键值对,可选,用于描述measurement (字符串型的键值对，用于描述这个点，可以用作索引) Timestamp - Measurement的确切时间点(微妙级时间戳)  这个模型是的我们可以高效而且便捷地插入Measurements。</description>
    </item>
    
    <item>
      <title>Go爬虫初探</title>
      <link>/post/2017/10/meet-go-scrapy/</link>
      <pubDate>Tue, 26 Sep 2017 23:29:00 +0800</pubDate>
      
      <guid>/post/2017/10/meet-go-scrapy/</guid>
      <description>背景 前些天用Python实践了一下爬虫功能，强大的requests库、re库、beautifulsoup库和scrapy框架以及其附属的分布式数据库配套库，开发起来十分高效。对于复杂的爬虫规则和验证规则，Python的相关生态也能提供很好的解决方案。回到golang，也想尝试是否能用go语言也构建一个基本爬虫，看实现上会有多大差异。
目标功能 获取 http://razil.cc 首页上的网站名称元素内容。
目标内容为“后端小筑”
基本结构 由于是基本的定向爬虫，类比Python的结构是
requests库 + re库
即基本请求后处理转码，再通过正则获得需要的数据
在go实现的结构如下:
 [net/http] 基本请求
 [mahonia] 第三方库实现编码转换
 [regexp] 正则匹配数据
  代码实现 package main import ( &amp;quot;errors&amp;quot; &amp;quot;fmt&amp;quot; &amp;quot;io/ioutil&amp;quot; &amp;quot;net/http&amp;quot; &amp;quot;regexp&amp;quot; encodingConvert &amp;quot;github.com/DennisMao/mahonia&amp;quot; ) func SimpleScrapy(url string) (string, error) { //http请求 resp, err := http.Get(url) if err != nil { return &amp;quot;&amp;quot;, err } //获取响应数据 if resp.StatusCode != 200 { return &amp;quot;&amp;quot;, errors.New(&amp;quot;resp statuscode = :&amp;quot; + fmt.</description>
    </item>
    
    <item>
      <title>Websocket使用手记</title>
      <link>/post/2017/07/gowebsocket-experience/</link>
      <pubDate>Thu, 21 Sep 2017 23:51:49 +0800</pubDate>
      
      <guid>/post/2017/07/gowebsocket-experience/</guid>
      <description>websocket是什么? Websocket最起初是在HTTP协议的基础上发展而来，后独立成为了一个标准。其特点是只要建立一次连接，即可保持服务端与客户端的长连接状态，期间可保持全双工的通讯(实时双方互传)。由于省去了重复建立连接产生的性能和带宽消耗，WebSocket可实现高性能的数据实时传递。
用于什么场景? 可应用在前后端数据需要实时数据互传的情况，比如：
 聊天系统 股票显示 实时交互游戏  为什么要选用它? 选用websocket的理由: + 相比起直接建立TCP连接，使用WebSocket可以更便捷，协议内已处理了粘包、压缩、心跳等问题。 + 协议的握手建立在http 1.1，因此在开发过程中可以很好的集成到现有的Restful风格中。 + 协议中的数据传递虽然是websocket的独立协议，但是其传输过程与http请求响应风格相近,开发难度低，学习成本低。 + 协议的本质还是建立一个socket连接。原生支持wss安全访问，底层支持数据压缩、自动检验和消息包自动拆分。 + 客户端应用简单，前端对于websocket的处理，代码简单，开发效率高。
使用过程 服务端 目前Go语言主流的Websocket库有两个：
 官方golang.org/x/websocket 库
 github.com/gorilla/websocket 库
  官方的库目前支持情况不太理想,godoc官方的websocket包页面介绍上推荐使用Gorilla的库。两者对比下，官方的包目前能够实现基本的服务器和客户端连接、收发功能。如果需要快捷开发基本WebSocket功能可使用官方包。需要协议的高级功能的推荐采用Gorilla包。
Gorilla/websocket包，丰富了支持Websocket协议内的数据压缩、心跳检测事件、碎片信息。
程序结构
websocket
 main()
 注册普通HTTP路由
 监听HTTP服务
 websocket_handler()
 Upgrade 升级普通HTTP协议为Websocket协议，建立连接
 For循环
 ReadMessage 读取信息
 WriteMessage 写入信息
     服务端的编写并不复杂，与普通HTTP服务编写相近，先编写一个Handler处理函数，再在主程序中注册路由，开启服务，不同的主要在处理函数中。由于普通HTTP的响应都是无状态，即请求后响应即可退出协程，但Websocket需要协程一直在跑，而且句柄固定，因此我们需要在Websocket的处理函数中加入循环，不让它关闭。
 客户端主动断开连接 服务端接收信息失败 服务端发送信息失败 心跳检查失败  客户端 javascript 参考websocket.</description>
    </item>
    
    <item>
      <title>Proto3使用手记</title>
      <link>/post/2017/08/proto3-note/</link>
      <pubDate>Tue, 22 Aug 2017 23:49:14 +0800</pubDate>
      
      <guid>/post/2017/08/proto3-note/</guid>
      <description>Proto3 是什么？ 最近正在使用gRPC，当前版本gRPC使用的是google开发的Proto 3版本，因此顺带写一篇。Proto 3全称是 Protocol buffers v3.0,是谷歌公司开发的一款序列化数据结构。支持多种语言。与proto2相比主要有以下几点改变：
 原生支持更多语言 JavaNano,Go,Ruby,Objective-C和C#等 调整部分语法 比如 default,optional,repeated 使得语法更简洁
 增加部分特性   具体改变介绍推荐以下这篇文章
Protobuf 的 proto3 与 proto2 的区别
最新特性详情可查阅
Protobuf Release
Proto3 有何功能? 通过定义接口描述文件 .proto文件，可通过这些描述自动生成出响应代码，用于编列或解码数据流。
为什么要选用它？ 使用过程中需要注意什么？ 使用过程 参考资料 Proto3 开发文档</description>
    </item>
    
    <item>
      <title>gRPC使用手记</title>
      <link>/post/2017/08/grpc-note/</link>
      <pubDate>Tue, 22 Aug 2017 23:44:21 +0800</pubDate>
      
      <guid>/post/2017/08/grpc-note/</guid>
      <description>gRPC是什么? gRPC是由谷歌开发的一款高性能，通用的开源RPC框架，基于HTTP/2协议标准设计.支持全双工、双向流、流控制、头部压缩单连接上的多服用请求等特性。目前提供C、Java和Go三个语言版本。 三个项目版本地址分别是: C-gRPC
Go-gRPC
JAVA-gRPC
为什么要选用它? 1.gRPC基于HTTP/2设计，相对于其他RPC框架，其功能更强大，真正实现全双工，支持头部压缩和多复用请求。因此能够很好的节省带宽和TCP链接次数，节省CPU使用，对于移动端的使用非常适用，也能提高云端的服务和Web应用性能。
2.支持Protobuf，在社区上看到不少人是出于Protobuf而选择gPRC.Protobuf拥有灵活、高效、结构化的特点，相比于其他传统的序列化方式，它更小、更快、更简单。其数据结构化一次可以支持多语言使用。支持不同版本的数据结构数据传递，实现数据结构的前向兼容。
3.拥有Golang版本（笔者选择的原因之一）
使用过程 Protobuf 3.0 安装protobuf
go get -u github.com/golang/protobuf/proto // golang protobuf 库  1、安装protoc工具，用于根据protobuf文件生成出Go代码
go get -u github.com/golang/protobuf/protoc-gen-go //protoc --go_out 工具  2、编写Protobuf3文件,可参考 helloword.proto
3、生成Go源代码，记得加上plugins=grpc否则将无法生成服务端接口
$ protoc -I helloworld/ helloworld/helloworld.proto --go_out=plugins=grpc:helloworld  gRPC 代码中需要引用到官方的context包，可在以下链接下载 https://github.com/golang/net 引用刚才我们通过protoc工具生成的代码并分别进行实现。
1、实现服务端代码,参考greeter_server
 package main import ( &amp;quot;log&amp;quot; &amp;quot;net&amp;quot; pb &amp;quot;your_path_to_gen_pb_dir/helloworld&amp;quot; &amp;quot;golang.org/x/net/context&amp;quot; &amp;quot;google.golang.org/grpc&amp;quot; ) // RPC服务端口 const ( port = &amp;quot;:50051&amp;quot; ) type server struct{} // 远程方法的具体实现 func (s *server) SayHello(ctx context.</description>
    </item>
    
    <item>
      <title>关于我</title>
      <link>/about/</link>
      <pubDate>Sun, 20 Aug 2017 09:49:04 +0800</pubDate>
      
      <guid>/about/</guid>
      <description>职位 后端开发工程师
工作经历 项目经历 技术栈 Golang、Java语言的Web后端，C++音视频。
联系方式 邮箱: psrazil@gmail.com Github: dennismao.github.com Blog: dennismao.github.io</description>
    </item>
    
    <item>
      <title>【Go】反射在Beego/Orm中的应用</title>
      <link>/post/2017/07/reflect-on-beego-orm/</link>
      <pubDate>Thu, 20 Jul 2017 15:03:41 +0800</pubDate>
      
      <guid>/post/2017/07/reflect-on-beego-orm/</guid>
      <description>应用 在Beego Orm中，作者使用了go的反射机制，实现 1、通过数据模型建立数据表
 type DataSheet struct { Name string orm:&amp;quot;NOT NULL&amp;quot; json:&amp;quot;name&amp;quot; //表名称 Type string orm:&amp;quot;NOT NULL&amp;quot; json:&amp;quot;type&amp;quot; //周期类型 日/月/季/年 Way string orm:&amp;quot;NOT NULL&amp;quot; json:&amp;quot;way&amp;quot; //生成方式 Time string orm:&amp;quot;NOT NULL&amp;quot; json:&amp;quot;time&amp;quot; //创建时间 Creator string orm:&amp;quot;NOT NULL&amp;quot; json:&amp;quot;creator&amp;quot; //制作人 }
 在调用 orm.RegisterModel(new(DataSheet)) 后会自动生成名为 data_sheet 的数据表 2、通过模型中的tag &amp;gt; orm:&amp;quot;auto;pk&amp;quot; &amp;gt; orm:&amp;quot;rel(m2m)&amp;quot;
自动设置字段属性和表之间关系
完整代码 package main import ( &amp;quot;errors&amp;quot; &amp;quot;fmt&amp;quot; &amp;quot;reflect&amp;quot; ) type DataSheet struct { Name string `orm:&amp;quot;NOT NULL&amp;quot; json:&amp;quot;name&amp;quot;` //表名称 Type string `orm:&amp;quot;NOT NULL&amp;quot; json:&amp;quot;type&amp;quot;` //周期类型 日/月/季/年 Way string `orm:&amp;quot;NOT NULL&amp;quot; json:&amp;quot;way&amp;quot;` //生成方式 Time string `orm:&amp;quot;NOT NULL&amp;quot; json:&amp;quot;time&amp;quot;` //创建时间 Creator string `orm:&amp;quot;NOT NULL&amp;quot; json:&amp;quot;creator&amp;quot;` //制作人 } func main() { fmt.</description>
    </item>
    
    <item>
      <title>【Go】解决“can&#39;t load package: no buildable Go source files in /...</title>
      <link>/post/2017/05/solve-no-buildable-go-source/</link>
      <pubDate>Sat, 20 May 2017 15:10:00 +0800</pubDate>
      
      <guid>/post/2017/05/solve-no-buildable-go-source/</guid>
      <description>最近在调用golang.org/x/net出现这个错误。经检查后解决方法如下。在调用外部包时候出现这种情况，应检查以下设置 &amp;gt; 1.目标外部包的编译环境是否与当前工程的环境相同 2.先使用go get 获取外部包 使用 go install 直接编译安装
关于本地未科学上网的情况下使用golang.org官方包的方法 &amp;gt; 1.到https://github.com/golang/找到对应的包的镜像文件 2.下载zip文件，解压后，修改文件目录为原始 golang.org目录 3.go install 编译安装
举个实例: golang.org/x/net 对应 github上的镜像地址是 https://github.com/golang/net</description>
    </item>
    
    <item>
      <title>【Go】常用的正则表达式</title>
      <link>/post/2017/05/go-regexp-pkg/</link>
      <pubDate>Wed, 17 May 2017 14:58:17 +0800</pubDate>
      
      <guid>/post/2017/05/go-regexp-pkg/</guid>
      <description>/*********************************************************** *名字 golang 正则工具 *功能 支持数字，字母，字符，常用信息（电话，邮箱）等的正则匹配 *作者 Razil ************************************************************/ package models import ( &amp;quot;regexp&amp;quot; ) type RegexCheck struct { } /************************* 自定义类型 ************************/ //数字+字母 不限制大小写 6~30位 func (ic *RegexCheck) IsID(str ...string) bool { var b bool for _, s := range str { b, _ = regexp.MatchString(&amp;quot;^[0-9a-zA-Z]{6,30}$&amp;quot;, s) if false == b { return b } } return b } //数字+字母+符号 6~30位 func (ic *RegexCheck) IsPwd(str ...string) bool { var b bool for _, s := range str { b, _ = regexp.</description>
    </item>
    
  </channel>
</rss>
