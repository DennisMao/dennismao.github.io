<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Json on 行者小筑</title>
    <link>/tags/json/</link>
    <description>Recent content in Json on 行者小筑</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 14 Dec 2017 00:22:45 +0800</lastBuildDate>
    <atom:link href="/tags/json/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>使用Go语言处理动态JSON类型</title>
      <link>/post/2017/12/dynamic-json/</link>
      <pubDate>Thu, 14 Dec 2017 00:22:45 +0800</pubDate>
      
      <guid>/post/2017/12/dynamic-json/</guid>
      <description>背景 在项目中有遇到JSON格式的数据流，对接的数据源其内容格式会有变化，但是内部会有字段表示其内容的类型，比如以下结构:
type DataJson struct { JsonType string `json:&amp;quot;json_type&amp;quot;` Data interface{} `json:&amp;quot;data&amp;quot;` }  其中DataJson是固定每次数据流返回的JSON数据格式，但是其中的Data有以下几种可能：字符串、Int64数值、结构体对象。
这种情况需要根据Json去进行判断。
生成动态类型 在Go语言中通过使用interface{}类型，我们可以很方便地把各种数据类型都使用同一个数据对象中进行数据传递。 动态类型生成方式很简单:
type DataJson struct { JsonType string `json:&amp;quot;json_type&amp;quot;` Data interface{} `json:&amp;quot;data&amp;quot;` } func main(){ //定义两个JSON数据对象 var jsData1,jsData2 DataJson //String数据类型对象 jsData1.JsonType = &amp;quot;string&amp;quot; jsData1.Data = &amp;quot;hello json&amp;quot; //Int64数据类型对象 jsData2.JsonType = &amp;quot;int64&amp;quot; jsData2.Data = 123456789	}  解析动态类型 方法一 整体二次反序列化 核心原理是通过新建一个对象，将能已知的数据对象先解析并获取到目标数据类型后再进行二次解析。
//目标类型 type DataJson struct { JsonType string `json:&amp;quot;json_type&amp;quot;` Data interface{} `json:&amp;quot;data&amp;quot;`	} //中间类型 type DataJsonType struct { JsonType string `json:&amp;quot;json_type&amp;quot;` } //字符串类型 type DataJsonTypeString struct { Data string `json:&amp;quot;data&amp;quot;` } func main(){ //原始JSON数据 var rawData = ` { &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;, &amp;quot;data&amp;quot;: &amp;quot;dynamite&amp;quot; } ` buffer := []byte(rawData) //创建中间类型对象 var md DataJsonType err := json.</description>
    </item>
    
  </channel>
</rss>
